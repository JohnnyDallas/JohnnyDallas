#!/usr/bin/env python
# coding: utf-8

# # Этап 1. Получение данных

# Изучим данные, предоставленные сервисом для проекта.

# ## Импорт библиотек

# In[261]:


import pandas as pd# <импорт библиотеки pandas>


# Прочитаем файл *music_project.csv* и сохраним его в переменной *df*. 

# In[262]:


df = pd.read_csv('/datasets/music_project.csv')# <чтение файла с данными с сохранением в df>


# Получение первых 10 строк таблицы.

# In[263]:


df.head(10)# <получение первых 10 строк таблицы df>


# Общая информация о данных таблицы *df*.
# 
# 
# 

# In[264]:


df.info()# <получение общей информации о данных в таблице df>


# Рассмотрим полученную информацию подробнее.
# 
# Всего в таблице 7 столбцов, тип данных у каждого столбца - object.
# 
# Подробно разберём, какие в *df* столбцы и какую информацию они содержат:
# 
# * userID — идентификатор пользователя;
# * Track — название трека;  
# * artist — имя исполнителя;
# * genre — название жанра;
# * City — город, в котором происходило прослушивание;
# * time — время, в которое пользователь слушал трек;
# * Day — день недели.
# 
# Количество значений в столбцах различается. Это говорит о том, что в данных есть <NaN> значения.
# 
# 

# In[ ]:





# **Выводы**

# Каждая строка таблицы содержит информацию о композициях определённого жанра в определённом исполнении, которые пользователи слушали в одном из городов в определённое время и день недели. Две проблемы, которые нужно решать: пропуски и некачественные названия столбцов. Для проверки рабочих гипотез особенно ценны столбцы *time*, *day* и *City*. Данные из столбца *genre* позволят узнать самые популярные жанры.

# # Этап 2. Предобработка данных

# Исключим пропуски, переименуем столбцы, а также проверим данные на наличие дубликатов.

# Получаем перечень названий столбцов. Какая наблюдается проблема — кроме тех, что уже были названы ранее?

# In[265]:


df.info('columns')# <перечень названий столбцов таблицы df>


# В названиях столбцов есть пробелы, которые могут затруднять доступ к данным.

# Переименуем столбцы для удобства дальнейшей работы. Проверим результат.
# 
# 

# In[266]:


new_names = ['user_id','track_name','artist_name','genre_name','city','time','weekday']
df.set_axis(['user_id','track_name','artist_name','genre_name','city','time','weekday'], axis = 'columns', inplace = True)# <переименование столбцов>


# In[267]:


df.info('columns')# <проверка результатов - перечень названий столбцов>


# Проверим данные на наличие пропусков вызовом набора методов для суммирования пропущенных значений.

# In[268]:


df.isnull().sum()# <суммарное количество пропусков, выявленных методом isnull() в таблице df>


# Пустые значения свидетельствуют, что для некоторых треков доступна не вся информация. Причины могут быть разные: скажем,  не назван конкретный исполнитель народной песни. Хуже, если проблемы с записью данных. Каждый отдельный случай необходимо разобрать и выявить причину.

# Заменяем пропущенные значения в столбцах с названием трека и исполнителя на строку 'unknown'. После этой операции нужно убедиться, что таблица больше не содержит пропусков.

# In[269]:


df['track_name'] = df['track_name'].fillna('unknown')# <замена пропущенных значений в столбце 'track_name' на строку 'unknown' специальным методом замены>


# In[270]:


df['artist_name'] = df['artist_name'].fillna('unknown')
# <замена пропущенных значений в столбце 'artist_name' на строку 'unknown' специальным методом замены>


# In[271]:


df.isnull().sum()# <проверка: вычисление суммарного количества пропусков, выявленных в таблице df>


# Удаляем в столбце с жанрами пустые значения; убеждаемся, что их больше не осталось.

# In[272]:


df.dropna(subset = ['genre_name'], inplace = True)# <удаление пропущенных значений в столбце 'genre_name'>


# In[273]:


df.isnull().sum()# <проверка>


# Необходимо установить наличие дубликатов.  Если найдутся, удаляем, и проверяем, все ли удалились.

# In[274]:


df.duplicated().sum()# <получение суммарного количества дубликатов в таблице df>


# In[275]:



df=df.drop_duplicates().reset_index(drop=True)# <удаление всех дубликатов из таблицы df специальным методом>


# In[276]:


df.duplicated().sum()
# <проверка на отсутствие>


# Дубликаты могли появиться вследствие сбоя в записи данных. Стоит обратить внимание и разобраться с причинами появления такого «информационного мусора».

# Сохраняем список уникальных значений столбца с жанрами в переменной *genres_list*. 
# 
# Объявим функцию *find_genre()* для поиска неявных дубликатов в столбце с жанрами. Например, когда название одного и того же жанра написано разными словами.
# 
# 
# 
# 

# In[277]:


genres_list=df['genre_name'].unique()# <сохранение в переменной genres_list списка уникальных значений, выявленных специальным методом в столбце 'genre_name'>


# In[278]:


def find_genre(genre):
    count = 0
    for i in genres_list:
        if i == genre:
            count += 1
    return count# <создание функции find_genre()>
# функция принимает как параметр строку с названием искомого жанра
# в теле объявляется переменная-счётчик, ей присваивается значение 0,
# затем цикл for проходит по списку уникальных значений
# если очередной элемент списка равен параметру функции, 
# то значение счётчика увеличивается на 1
# по окончании работы цикла функция возвращает значение счётчика


# Вызов функции *find_genre()* для поиска различных вариантов названия жанра хип-хоп в таблице.
# 
# Правильное название — *hiphop*. Поищем другие варианты:
# 
# * hip
# * hop
# * hip-hop
# 

# In[279]:


find_genre('hip')# <вызовом функции find_genre() проверяется наличие варианта 'hip'>


# In[280]:


find_genre('hop')# <проверяется наличие варианта 'hop'>


# In[281]:


find_genre('hip-hop')# <проверяется наличие варианта 'hip-hop'>


# Объявим функцию *find_hip_hop()*, которая заменяет  неправильное название этого жанра в столбце *'genre_name'* на *'hiphop'* и проверяет успешность выполнения замены.
# 
# Так исправляем все варианты написания, которые выявила проверка.

# In[282]:


def find_hip_hop(df,wrong):
    df['genre_name'] = df['genre_name'].replace(wrong, 'hiphop')
    count = df[df['genre_name'] == wrong]['genre_name'].count()
    return count# <создание функции find_hip_hop()>
# функция принимает как параметры таблицу df и неверное название
# к столбцу 'genre_name' применяется специальный метод, 
# который заменяет второй параметр на строку 'hiphop'
# результат работы равен подсчитанному методом count() числу значений столбца, 
# которые равны второму параметру
# функция возвращает результат


# In[283]:


find_hip_hop(df,'hip')# <замена одного неверного варианта на hiphop вызовом функции find_hip_hop()>


# Получаем общую информацию о данных. Убеждаемся, что чистка выполнена успешно.

# In[284]:


df.info()# <получение общей информации о данных таблицы df>


# **Вывод**

# На этапе предобработки в данных обнаружились не только пропуски и проблемы с названиями столбцов, но и всяческие виды дубликатов. Их удаление позволит провести анализ точнее. Поскольку сведения о жанрах важно сохранить для анализа, не просто удаляем все пропущенные значения, но заполним пропущенные имена исполнителей и названия треков. Имена столбцов теперь корректны и удобны для дальнейшей работы.

# # Действительно ли музыку в разных городах слушают по-разному?

# Была выдвинута гипотеза, что в Москве и Санкт-Петербурге пользователи слушают музыку по-разному. Проверяем это предположение по данным о трёх днях недели — понедельнике, среде и пятнице.
# 
# Для каждого города устанавливаем количество прослушанных  в эти дни композиций с известным жанром, и сравниваем результаты.

# Группируем данные по городу и вызовом метода *count()* подсчитываем композиции, для которых известен жанр.

# In[285]:


df.groupby('city')['genre_name'].count()# <группировка данных таблицы df по столбцу 'city' и подсчёт количества значений столбца 'genre_name'>


# В Москве прослушиваний больше, чем в Питере, но это не значит, что Москва более активна. У Яндекс.Музыки в целом больше пользователей в Москве, поэтому величины сопоставимы.

# Сгруппируем данные по дню недели и подсчитаем прослушанные в понедельник, среду и пятницу композиции, для которых известен жанр.

# In[286]:


df.groupby('weekday')['genre_name'].count()# <группировка данных по столбцу 'weekday' и подсчёт количества значений столбца 'genre_name'>


# Понедельник и пятница — время для музыки; по средам пользователи немного больше вовлечены в работу.

# Создаём функцию *number_tracks()*, которая принимает как параметры таблицу, день недели и название города, а возвращает количество прослушанных композиций, для которых известен жанр. Проверяем количество прослушанных композиций для каждого города и понедельника, затем среды и пятницы.

# In[287]:


def number_tracks(df,day,city):
    track_list=df[(df['weekday']==day) & (df['city']==city)]
    track_list_count=track_list['genre_name'].count()
    return track_list_count# <создание функции number_tracks()>
# объявляется функция с тремя параметрами: df, day, city
# в переменной track_list сохраняются те строки таблицы df, для которых 
# значение в столбце 'weekday' равно параметру day
# и одновременно значение в столбце 'city' равно параметру city
# в переменной track_list_count сохраняется число значений столбца 'genre_name',
# рассчитанное методом count() для таблицы track_list
# функция возвращает значение track_list_count


# In[288]:


number_tracks(df, 'Monday', 'Moscow')# <список композиций для Москвы в понедельник>


# In[289]:


number_tracks(df, 'Monday', 'Saint-Petersburg')# <список композиций для Санкт-Петербурга в понедельник>


# In[290]:


number_tracks(df, 'Wednesday', 'Moscow')# <список композиций для Москвы в среду>


# In[291]:


number_tracks(df, 'Wednesday', 'Saint-Petersburg')# <список композиций для Санкт-Петербурга в среду>


# In[292]:


number_tracks(df, 'Friday', 'Moscow')# <список композиций для Москвы в пятницу>


# In[293]:


number_tracks(df, 'Friday', 'Saint-Petersburg')# <список композиций для Санкт-Петербурга в пятницу>


# Сведём полученную информацию в одну таблицу, где ['city', 'monday', 'wednesday', 'friday'] названия столбцов.
# 

# In[294]:


data=[['Moscow', 15347, 10865, 15680],
       ['Saint-Petersburg', 5519, 6913, 5802]]
columns = ['city','monday','wednesday','friday']
table=pd.DataFrame(data=data, columns=columns)# <таблица с полученными данными>


# **Вывод**

# Результаты показывают, что относительно среды музыку в Петербурге и Москве слушают «зеркально»: в Москве пики приходятся на понедельник и пятницу, а в среду время прослушивания снижается. Тогда как в Санкт-Петербурге среда — день самого большого интереса к музыке, а в понедельник и пятницу он меньше, причём почти одинаково меньше.

# # Утро понедельника и вечер пятницы — разная музыка или одна и та же?

# Ищем ответ на вопрос, какие жанры преобладают в разных городах в понедельник утром и в пятницу вечером. Есть предположение, что в понедельник утром пользователи слушают больше бодрящей музыки (например, жанра поп), а вечером пятницы — больше танцевальных (например, электронику).

# Получим таблицы данных по Москве *moscow_general* и по Санкт-Петербургу *spb_general*.

# In[295]:


moscow_general=df.loc[df.loc[:,'city']=='Moscow']# получение таблицы moscow_general из тех строк таблицы df, 
# для которых значение в столбце 'city' равно 'Moscow'


# In[296]:


spb_general=df.loc[df.loc[:,'city']=='Saint-Petersburg']# <получение таблицы spb_general>


# Создаём функцию *genre_weekday()*, которая возвращает список жанров по запрошенному дню недели и времени суток с такого-то часа по такой-то.

# In[302]:


def genre_weekday(df, day, time1, time2):
    genre_list = df[(df['weekday'] == day) & (df['time'] > time1) & (df['time'] < time2)]
    genre_list_sorted=genre_list.groupby('genre_name')['genre_name'].count().sort_values(ascending = False).head(10)              
    return genre_list_sorted # 1) значение в столбце 'weekday' равно параметру day,
# 2) значение в столбце 'time' больше time1 и
# 3) меньше time2.
# в переменной genre_list_sorted сохраняются в порядке убывания  
# первые 10 значений Series, полученной подсчётом числа значений 'genre_name'
# сгруппированной по столбцу 'genre_name' таблицы genre_list
# функция возвращает значение genre_list_sorted


# Cравниваем полученные результаты по таблице для Москвы и Санкт-Петербурга в понедельник утром (с 7 до 11) и в пятницу вечером (с 17 до 23).

# In[303]:


genre_weekday(moscow_general, 'Monday','07:00:00', '11:00:00')# <вызов функции для утра понедельника в Москве (вместо df таблица moscow_general)>


# In[304]:


genre_weekday(spb_general, 'Monday','07:00:00', '11:00:00')# <вызов функции для утра понедельника в Петербурге (вместо df таблица spb_general)>


# In[305]:


genre_weekday(moscow_general, 'Friday','17:00:00', '23:00:00')# <вызов функции для вечера пятницы в Москве>


# In[306]:


genre_weekday(spb_general, 'Friday','17:00:00', '23:00:00')# <вызов функции для вечера пятницы в Питере>


# Популярные жанры в понедельник утром в Питере и Москве оказались похожи: везде, как и предполагалось, популярен поп. Несмотря на это, концовка топ-10 для двух городов различается: в Питере в топ-10 входит джаз и русский рэп, а в Москве жанр *world*.
# 
# В конце недели ситуация не меняется. Поп-музыка всё так же на первом месте. Опять разница заметна только в концовке топ-10, где в Питере пятничным вечером тоже присутствует жанр *world*.

# **Вывод**

# Жанр поп безусловный лидер, а топ-5 в целом не различается в обеих столицах. При этом видно, что концовка списка более «живая»: для каждого города выделяются более характерные жанры, которые действительно меняют свои позиции в зависимости от дня недели и времени.

# # Москва и Питер — две разные столицы, два разных направления в музыке. Правда?

# Гипотеза: Питер богат своей рэп-культурой, поэтому это направление там слушают чаще, а Москва — город контрастов, но основная масса пользователей слушает попсу.
# 
# 

# Сгруппируем таблицу *moscow_general* по жанру, сосчитаем численность композиций каждого жанра методом *count()*, отсортируем в порядке убывания и сохраним результат в таблице *moscow_genres*.
# 
# Просмотрим первые 10 строк этой новой таблицы.

# In[308]:


# подсчёт числа значений 'genre_name' в этой группировке методом count(), 
moscow_genres = moscow_general.groupby('genre_name')['genre_name'].count().sort_values(ascending=False)# сортировка Series в порядке убывания и сохранение в moscow_genres


# In[309]:


moscow_genres.head(10)# <просмотр первых 10 строк moscow_genres>


# Сгруппируем таблицу *spb_general* по жанру, сосчитаем численность композиций каждого жанра методом *count()*, отсортируем в порядке убывания и сохраним результат в таблице *spb_genres*.
# 
# Просматриваем первые 10 строк этой таблицы. Теперь можно сравнивать два города.

# In[310]:


spb_genres = spb_general.groupby('genre_name')['genre_name'].count().sort_values(ascending=False)# <группировка таблицы spb_general, расчёт, сохранение в spb_genres>


# In[311]:


spb_genres.head(10)# <просмотр первых 10 строк spb_genres>


# **Вывод**

# В Москве, кроме абсолютно популярного жанра поп, есть направление русской популярной музыки. Значит, что интерес к этому жанру шире. А рэп, вопреки предположению, занимает в обоих городах близкие позиции.

# # Этап 4. Результаты исследования
# 

# Рабочие гипотезы:
# 
# * музыку в двух городах — Москве и Санкт-Петербурге — слушают в разном режиме;
# 
# * списки десяти самых популярных жанров утром в понедельник и вечером в пятницу имеют характерные отличия;
# 
# * население двух городов предпочитает разные музыкальные жанры.
# 
# **Общие результаты**
# 
# Москва и Петербург сходятся во вкусах: везде преобладает популярная музыка. При этом зависимости предпочтений от дня недели в каждом отдельном городе нет — люди постоянно слушают то, что им нравится. Но между городами в разрезе дней неделей наблюдается зеркальность относительно среды: Москва больше слушает в понедельник и пятницу, а Петербург наоборот - больше в среду, но меньше в понедельник и пятницу.
# 
# В результате первая гипотеза < укажите подтверждена/не подтверждена>, вторая гипотеза < укажите подтверждена/не подтверждена > и третья < укажите подтверждена/не подтверждена >.
